#include <rclcpp/rclcpp.hpp>
#include <nav_msgs/msg/path.hpp>
#include <geometry_msgs/msg/twist.hpp>
#include <tf2_ros/transform_listener.h>
#include <tf2_ros/buffer.h>
#include <tf2_geometry_msgs/tf2_geometry_msgs.hpp>
#include <cmath>

class PathFollower : public rclcpp::Node {
public:
    PathFollower() : Node("path_follower") {
        // Subscribe to the path generated by A*
        sub_path_ = this->create_subscription<nav_msgs::msg::Path>(
            "/planned_path", 10, std::bind(&PathFollower::path_callback, this, std::placeholders::_1));

        // Publish velocity commands to move the wheels
        pub_vel_ = this->create_publisher<geometry_msgs::msg::Twist>("/cmd_vel_raw", 10);

        // TF Buffer to know where the robot is
        tf_buffer_ = std::make_unique<tf2_ros::Buffer>(this->get_clock());
        tf_listener_ = std::make_shared<tf2_ros::TransformListener>(*tf_buffer_);

        // Control Loop (20Hz)
        timer_ = this->create_wall_timer(
            std::chrono::milliseconds(50), std::bind(&PathFollower::control_loop, this));

        RCLCPP_INFO(this->get_logger(), "âœ… Path Follower Ready. Waiting for path...");
    }

private:
    void path_callback(const nav_msgs::msg::Path::SharedPtr msg) {
        current_path_ = *msg;
        current_goal_index_ = 0; // Reset tracking to start of new path
        path_received_ = true;
        RCLCPP_INFO(this->get_logger(), "Received new path with %lu points.", current_path_.poses.size());
    }

    void control_loop() {
        if (!path_received_ || current_path_.poses.empty()) return;

        // 1. Get Robot Pose
        geometry_msgs::msg::TransformStamped t;
        try {
            t = tf_buffer_->lookupTransform("map", "base_link", tf2::TimePointZero);
        } catch (const tf2::TransformException &ex) {
            return; // Robot position unknown yet
        }

        double robot_x = t.transform.translation.x;
        double robot_y = t.transform.translation.y;
        
        // Convert Quaternion to Yaw (Heading)
        tf2::Quaternion q(
            t.transform.rotation.x, t.transform.rotation.y,
            t.transform.rotation.z, t.transform.rotation.w);
        tf2::Matrix3x3 m(q);
        double roll, pitch, robot_yaw;
        m.getRPY(roll, pitch, robot_yaw);

        // 2. Find the Lookahead Point
        // We skip points that are too close (already passed)
        // Look for a point ~0.5m ahead
        bool end_reached = false;
        while (true) {
            if (current_goal_index_ >= current_path_.poses.size()) {
                end_reached = true;
                break;
            }
            
            double gx = current_path_.poses[current_goal_index_].pose.position.x;
            double gy = current_path_.poses[current_goal_index_].pose.position.y;
            double dist = std::hypot(gx - robot_x, gy - robot_y);

            if (dist > 0.3) break; // Found a point 30cm away, go there
            current_goal_index_++;
        }

        geometry_msgs::msg::Twist cmd;

        // 3. Stop if reached end
        if (end_reached) {
            cmd.linear.x = 0.0;
            cmd.angular.z = 0.0;
            pub_vel_->publish(cmd);
            if (path_received_) {
                RCLCPP_INFO(this->get_logger(), "ðŸŽ‰ GOAL REACHED!");
                path_received_ = false; // Stop trying to move
            }
            return;
        }

        // 4. Calculate Control Command (Pure Pursuit Logic)
        double target_x = current_path_.poses[current_goal_index_].pose.position.x;
        double target_y = current_path_.poses[current_goal_index_].pose.position.y;

        double angle_to_goal = std::atan2(target_y - robot_y, target_x - robot_x);
        double angle_error = angle_to_goal - robot_yaw;

        // Normalize angle to [-PI, PI]
        while (angle_error > M_PI) angle_error -= 2.0 * M_PI;
        while (angle_error < -M_PI) angle_error += 2.0 * M_PI;

        // Simple Proportional Controller
        cmd.angular.z = 1.5 * angle_error; // Turn speed
        
        // Slow down if turning sharply
        if (std::abs(angle_error) > 0.5) {
            cmd.linear.x = 0.0; // Turn in place
        } else {
            cmd.linear.x = 0.3; // Drive forward (0.3 m/s)
        }

        pub_vel_->publish(cmd);
    }

    rclcpp::Subscription<nav_msgs::msg::Path>::SharedPtr sub_path_;
    rclcpp::Publisher<geometry_msgs::msg::Twist>::SharedPtr pub_vel_;
    rclcpp::TimerBase::SharedPtr timer_;
    std::shared_ptr<tf2_ros::TransformListener> tf_listener_;
    std::unique_ptr<tf2_ros::Buffer> tf_buffer_;

    nav_msgs::msg::Path current_path_;
    size_t current_goal_index_ = 0;
    bool path_received_ = false;
};

int main(int argc, char** argv) {
    rclcpp::init(argc, argv);
    rclcpp::spin(std::make_shared<PathFollower>());
    rclcpp::shutdown();
    return 0;
}
